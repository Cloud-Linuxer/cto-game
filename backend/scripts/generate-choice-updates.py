#!/usr/bin/env python3
import json
import re

# Î∞±ÏóÖ ÌååÏùº ÏùΩÍ∏∞
with open('backup/choices_backup_2025-10-02T07-09-42-427Z.json', 'r', encoding='utf-8') as f:
    choices = json.load(f)

# Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÏÑ§Î™Ö Îß§Ìïë
category_descriptions = {
    "marketing": ["ÏûÖÏÜåÎ¨∏ÏùÑ ÌÉÄÍ≥† Îπ†Î•¥Í≤å ÌôïÏÇ∞Îê©ÎãàÎã§", "Î∏åÎûúÎìú Ïù∏ÏßÄÎèÑÎ•º ÎÜíÏûÖÎãàÎã§", "ÌÉÄÍ≤ü Í≥†Í∞ùÏ∏µÏóêÍ≤å Ìö®Í≥ºÏ†ÅÏúºÎ°ú ÎèÑÎã¨Ìï©ÎãàÎã§"],
    "infra": ["ÏïàÏ†ïÏ†ÅÏù∏ ÏÑúÎπÑÏä§ Ïö¥ÏòÅÏù¥ Í∞ÄÎä•Ìï¥ÏßëÎãàÎã§", "ÌôïÏû• Í∞ÄÎä•Ìïú Ïù∏ÌîÑÎùºÎ•º Íµ¨Ï∂ïÌï©ÎãàÎã§", "Í∏∞Ïà†Ï†Å Ïö∞ÏúÑÎ•º ÌôïÎ≥¥Ìï©ÎãàÎã§"],
    "feature": ["ÏÇ¨Ïö©Ïûê Í≤ΩÌóòÏùÑ ÌòÅÏã†Ï†ÅÏúºÎ°ú Í∞úÏÑ†Ìï©ÎãàÎã§", "Ï∞®Î≥ÑÌôîÎêú Í∞ÄÏπòÎ•º Ï†úÍ≥µÌï©ÎãàÎã§", "Í≤ΩÏüÅÏÇ¨ÏôÄÏùò Í≤©Ï∞®Î•º Î≤åÎ¶ΩÎãàÎã§"],
    "investment": ["ÏÑ±Ïû•ÏùÑ ÏúÑÌïú ÏûêÍ∏àÏùÑ ÌôïÎ≥¥Ìï©ÎãàÎã§", "Ï†ÑÎûµÏ†Å ÌååÌä∏ÎÑàÎ•º ÏñªÏäµÎãàÎã§", "Îã§Ïùå Îã®Í≥ÑÎ°ú ÎèÑÏïΩÌï©ÎãàÎã§"],
    "hr": ["ÌåÄ Ïó≠ÎüâÏù¥ ÌÅ¨Í≤å Í∞ïÌôîÎê©ÎãàÎã§", "Ï†ÑÎ¨∏ÏÑ±ÏùÑ ÌôïÎ≥¥Ìï©ÎãàÎã§", "Ï°∞ÏßÅ Î¨∏ÌôîÎ•º Î∞úÏ†ÑÏãúÌÇµÎãàÎã§"],
    "revenue": ["ÏßÄÏÜç Í∞ÄÎä•Ìïú ÏàòÏùµ Î™®Îç∏ÏùÑ ÎßåÎì≠ÎãàÎã§", "Ïû¨Î¨¥ Í±¥Ï†ÑÏÑ±ÏùÑ ÌôïÎ≥¥Ìï©ÎãàÎã§", "Ìà¨ÏûêÏûêÎì§Ïùò Ïã†Î¢∞Î•º ÏñªÏäµÎãàÎã§"],
    "global": ["ÏÑ∏Í≥Ñ ÏãúÏû•ÏúºÎ°ú ÎÇòÏïÑÍ∞ëÎãàÎã§", "Í∏ÄÎ°úÎ≤å Í≤ΩÏüÅÎ†•ÏùÑ Í∞ñÏ∂•ÎãàÎã§", "Î¨¥ÌïúÌïú Í∞ÄÎä•ÏÑ±ÏùÑ Ïó¥Ïñ¥Í∞ëÎãàÎã§"],
    "crisis": ["ÏúÑÍ∏∞Î•º Í∏∞ÌöåÎ°ú Ï†ÑÌôòÌï©ÎãàÎã§", "Îçî Í∞ïÌïú ÌöåÏÇ¨Î°ú Í±∞Îì≠ÎÇ©ÎãàÎã§", "Ïã†Î¢∞Î•º ÌöåÎ≥µÌï©ÎãàÎã§"]
}

def extract_title(text):
    """ÏÑ†ÌÉùÏßÄ ÌÖçÏä§Ìä∏ÏóêÏÑú Ï†úÎ™© Ï∂îÏ∂ú"""
    lines = text.strip().split('\n')
    if lines:
        # Í¥ÑÌò∏ ÏïàÏùò Í∏àÏï° Ï†úÍ±∞
        title = re.sub(r'\s*\([^)]*\)\s*$', '', lines[0])
        return title
    return "ÏÑ†ÌÉù"

def get_emoji_for_category(category, title):
    """Ïπ¥ÌÖåÍ≥†Î¶¨ÏôÄ Ï†úÎ™©Ïóê ÎßûÎäî Ïù¥Î™®ÏßÄ ÏÑ†ÌÉù"""
    emoji_map = {
        "marketing": "üì¢",
        "infra": "üèóÔ∏è",
        "feature": "‚ú®",
        "investment": "üí∞",
        "hr": "üë•",
        "revenue": "üíé",
        "global": "üåç",
        "crisis": "üö®",
        "Î≥¥Ïïà": "üõ°Ô∏è",
        "AI": "ü§ñ",
        "Îç∞Ïù¥ÌÑ∞": "üìä",
        "ÌååÌä∏ÎÑà": "ü§ù",
        "IPO": "üîî",
        "Í∞úÎ∞ú": "üíª",
        "ÎîîÏûêÏù∏": "üé®",
        "Í∏∞Ìöç": "üìã",
        "ÌÅ¥ÎùºÏö∞Îìú": "‚òÅÔ∏è",
        "ÏûêÎèôÌôî": "‚öôÔ∏è",
        "ÌîÑÎ¶¨ÎØ∏ÏóÑ": "üíé",
        "Í∏ÄÎ°úÎ≤å": "üåê",
        "ÌòÅÏã†": "üí°"
    }

    # Ï†úÎ™©ÏóêÏÑú ÌÇ§ÏõåÎìú Ï∞æÍ∏∞
    for keyword, emoji in emoji_map.items():
        if keyword in title:
            return emoji

    # Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ Í∏∞Î≥∏ Ïù¥Î™®ÏßÄ
    if category in emoji_map:
        return emoji_map[category]

    return "üéØ"

def generate_storytelling(choice):
    """ÏÑ†ÌÉùÏßÄÎ•º Ïä§ÌÜ†Î¶¨ÌÖîÎßÅÏúºÎ°ú Î≥ÄÌôò"""
    original_text = choice.get('text', '')
    category = choice.get('category', 'general')
    choice_id = choice.get('choiceId')

    # Ï†úÎ™© Ï∂îÏ∂ú
    title = extract_title(original_text)
    emoji = get_emoji_for_category(category, title)

    # ÌÇ§ÏõåÎìú Í∏∞Î∞ò Ïπ¥ÌÖåÍ≥†Î¶¨ ÏûêÎèô Îß§Ïπ≠
    if not category or category == '':
        # Ï†úÎ™©ÏóêÏÑú Ïπ¥ÌÖåÍ≥†Î¶¨ Ï∂îÎ°†
        if "ÎßàÏºÄÌåÖ" in title or "Ï∫†ÌéòÏù∏" in title or "Í¥ëÍ≥†" in title or "ÌôçÎ≥¥" in title or "ÌîÑÎ°úÎ™®ÏÖò" in title or "SNS" in title or "Ïú†Ï†Ä" in title:
            category = "marketing"
        elif "Ïù∏ÌîÑÎùº" in title or "EC2" in title or "Aurora" in title or "CloudFront" in title or "CDN" in title or "Redis" in title or "RDS" in title or "S3" in title or "EKS" in title or "Lambda" in title or "ÏÑúÎ≤Ñ" in title or "Ïä§ÏºÄÏùº" in title or "t4g" in title or "AWS" in title or "ÌÅ¥ÎùºÏö∞Îìú" in title or "DB" in title or "Îç∞Ïù¥ÌÑ∞Î≤†Ïù¥Ïä§" in title or "ÎÑ§Ìä∏ÏõåÌÅ¨" in title or "Î°úÎìú" in title or "Î∞±ÏóÖ" in title or "WAF" in title or "Î≥¥Ïïà" in title:
            category = "infra"
        elif "Í∏∞Îä•" in title or "Í∞úÎ∞ú" in title or "Î¶¨Ìå©ÌÜ†ÎßÅ" in title or "API" in title or "UI" in title or "UX" in title or "Î™®Î∞îÏùº" in title or "Ïï±" in title or "Î≤ÑÏ†Ñ" in title or "ÏóÖÎç∞Ïù¥Ìä∏" in title or "Ï∂úÏãú" in title or "Îü∞Ïπ≠" in title or "ÌîÑÎ°úÌïÑ" in title or "ÏïåÎ¶º" in title or "Í≤∞Ï†ú" in title or "Î°úÍ∑∏Ïù∏" in title or "ÏÜåÏÖú" in title or "Ïã§ÏãúÍ∞Ñ" in title:
            category = "feature"
        elif "Ìà¨Ïûê" in title or "ÏãúÎ¶¨Ï¶à" in title or "VC" in title or "ÌéÄÎî©" in title or "ÏûêÍ∏à" in title or "ÏóîÏ†§" in title or "Ïñµ" in title:
            category = "investment"
        elif "Ï±ÑÏö©" in title or "ÌåÄ" in title or "Ïù∏Î†•" in title or "ÏòÅÏûÖ" in title or "Ï°∞ÏßÅ" in title or "HR" in title or "Ïù∏ÏÇ¨" in title or "CTO" in title or "CFO" in title or "CMO" in title:
            category = "hr"
        elif "ÏàòÏùµ" in title or "Îß§Ï∂ú" in title or "ÌùëÏûê" in title or "ÎπÑÏ¶àÎãàÏä§" in title or "ÌîåÎûú" in title or "Í∞ÄÍ≤©" in title or "Íµ¨ÎèÖ" in title or "ÌîÑÎ¶¨ÎØ∏ÏóÑ" in title or "Ïú†Î£å" in title or "Í≤∞Ï†ú" in title or "B2B" in title or "B2C" in title or "SI" in title or "Ïª®ÏÑ§ÌåÖ" in title:
            category = "revenue"
        elif "Í∏ÄÎ°úÎ≤å" in title or "Ìï¥Ïô∏" in title or "ÏßÑÏ∂ú" in title or "ÌòÑÏßÄ" in title or "ÎèÑÏøÑ" in title or "Ïã±Í∞ÄÌè¨Î•¥" in title or "ÎØ∏Íµ≠" in title or "ÏùºÎ≥∏" in title or "Ï§ëÍµ≠" in title:
            category = "global"
        elif "ÏúÑÍ∏∞" in title or "Í∏¥Í∏â" in title or "Ïû•Ïï†" in title or "Î≥µÍµ¨" in title or "ÏÇ¨Í≥†" in title or "Ìï¥ÌÇπ" in title or "DDoS" in title:
            category = "crisis"
        elif "Í≥ÑÏÜç" in title or "Ïú†ÏßÄ" in title or "ÌòÑÏû¨" in title:
            category = "maintain"
        else:
            # Í∏àÏï°Ïù¥ÎÇò Ïà´ÏûêÍ∞Ä Ìè¨Ìï®Îêú Í≤ΩÏö∞ revenueÎ°ú Î∂ÑÎ•ò
            if "ÎßåÏõê" in title or "Ï≤úÎßå" in title or "ÏñµÏõê" in title:
                category = "revenue"
            else:
                category = "general"

    # Ïπ¥ÌÖåÍ≥†Î¶¨Î≥Ñ ÏÑ§Î™Ö ÏÑ†ÌÉù
    descriptions = category_descriptions.get(category, [
        "ÏÉàÎ°úÏö¥ Í∏∞ÌöåÎ•º Ï∞ΩÏ∂úÌï©ÎãàÎã§",
        "Ï†ÑÎûµÏ†Å ÏÑ†ÌÉùÏù¥ Îê† Í≤ÉÏûÖÎãàÎã§",
        "ÎØ∏ÎûòÎ•º ÏúÑÌïú Ìà¨ÏûêÏûÖÎãàÎã§"
    ])

    # ÌäπÏàò ÏºÄÏù¥Ïä§ Ï≤òÎ¶¨
    if "IPO" in title:
        return f"{emoji} {title}\\n\\nÎìúÎîîÏñ¥ ÏÉÅÏû•Ïùò ÍøàÏùÑ Ïã§ÌòÑÌï©ÎãàÎã§.\\nÏ£ºÏãùÏãúÏû•Ïóê ÌöåÏÇ¨Î•º Í≥µÍ∞úÌï©ÎãàÎã§.\\nÏÉàÎ°úÏö¥ ÏÑ±Ïû• Îã®Í≥ÑÎ°ú ÏßÑÏûÖÌï©ÎãàÎã§."
    elif "Í∏¥Í∏â" in title or "ÎπÑÏÉÅ" in title:
        return f"{emoji} {title}\\n\\nÏúÑÍ∏∞ ÏÉÅÌô©Ïóê Ï¶âÍ∞Å ÎåÄÏùëÌï©ÎãàÎã§.\\nÎ™®Îì† Ïó≠ÎüâÏùÑ ÏßëÏ§ëÌïòÏó¨ Î¨∏Ï†úÎ•º Ìï¥Í≤∞Ìï©ÎãàÎã§.\\nÏã†ÏÜçÌïòÍ≥† Ï†ïÌôïÌïú ÌåêÎã®Ïù¥ ÌïÑÏöîÌï©ÎãàÎã§."
    elif "Í≥ÑÏÜçÌïòÍ∏∞" in title:
        return f"{emoji} {title}\\n\\nÏïÑÏßÅ Ï§ÄÎπÑÍ∞Ä Îçî ÌïÑÏöîÌï©ÎãàÎã§.\\nÎçî ÏÑ±Ïû•Ìïú ÌõÑ Ïû¨ÎèÑÏ†ÑÌï©ÎãàÎã§.\\nÌòÑÏû¨ Ï†ÑÎûµÏùÑ Ïú†ÏßÄÌï©ÎãàÎã§."
    elif "DR" in title or "Ïû¨Ìï¥Î≥µÍµ¨" in title:
        return f"{emoji} {title}\\n\\nÏñ¥Îñ§ ÏÉÅÌô©ÏóêÎèÑ ÏÑúÎπÑÏä§Í∞Ä Ï§ëÎã®ÎêòÏßÄ ÏïäÏäµÎãàÎã§.\\nÏôÑÎ≤ΩÌïú Î∞±ÏóÖÍ≥º Î≥µÍµ¨ Ï≤¥Í≥ÑÎ•º Í∞ñÏ∂•ÎãàÎã§.\\nÍ≥†Í∞ùÏùò Ï†àÎåÄÏ†Å Ïã†Î¢∞Î•º ÏñªÏäµÎãàÎã§."
    elif "Ï±ÑÏö©" in title or "ÏòÅÏûÖ" in title:
        role = ""
        if "Í∞úÎ∞ú" in title:
            role = "Í∞úÎ∞ú Ïó≠ÎüâÏùÑ ÌÅ¨Í≤å Í∞ïÌôîÌï©ÎãàÎã§.\\nÎçî Îπ†Î•∏ Í∏∞Îä• Í∞úÎ∞úÏù¥ Í∞ÄÎä•Ìï¥ÏßëÎãàÎã§."
        elif "ÎîîÏûêÏù∏" in title:
            role = "ÏÇ¨Ïö©Ïûê Í≤ΩÌóòÏùÑ ÌòÅÏã†Ï†ÅÏúºÎ°ú Í∞úÏÑ†Ìï©ÎãàÎã§.\\nÏïÑÎ¶ÑÎãµÍ≥† ÏßÅÍ¥ÄÏ†ÅÏù∏ Ïù∏ÌÑ∞ÌéòÏù¥Ïä§Î•º ÎßåÎì≠ÎãàÎã§."
        elif "Í∏∞Ìöç" in title:
            role = "Ï≤¥Í≥ÑÏ†ÅÏù∏ ÏÑúÎπÑÏä§ Í∏∞ÌöçÏù¥ Í∞ÄÎä•Ìï¥ÏßëÎãàÎã§.\\nÏÇ¨Ïö©Ïûê ÏöîÍµ¨Î•º Ï†ïÌôïÌûà ÌååÏïÖÌï©ÎãàÎã§."
        elif "ÎßàÏºÄ" in title:
            role = "Ï†ÑÎ¨∏Ï†ÅÏù∏ ÎßàÏºÄÌåÖ Ï†ÑÎûµÏùÑ ÏàòÎ¶ΩÌï©ÎãàÎã§.\\nÌö®Í≥ºÏ†ÅÏù∏ Í≥†Í∞ù ÌöçÎìùÏù¥ Í∞ÄÎä•Ìï¥ÏßëÎãàÎã§."
        else:
            role = "ÏµúÍ≥†Ïùò Ïù∏Ïû¨Îì§ÏùÑ ÏòÅÏûÖÌï©ÎãàÎã§.\\nÏ°∞ÏßÅ Ïó≠ÎüâÏùÑ ÌÅ¨Í≤å Í∞ïÌôîÌï©ÎãàÎã§."
        return f"{emoji} {title}\\n\\n{role}\\nÎã§Ïùå Îã®Í≥Ñ ÏÑ±Ïû•ÏùÑ ÏúÑÌïú ÌåÄÏùÑ Íµ¨ÏÑ±Ìï©ÎãàÎã§."

    # ÏùºÎ∞òÏ†ÅÏù∏ Ïä§ÌÜ†Î¶¨ÌÖîÎßÅ ÏÉùÏÑ±
    story = f"{emoji} {title}\\n\\n"
    story += f"{descriptions[0]}\\n"
    story += f"{descriptions[1]}\\n"
    story += f"{descriptions[2]}"

    return story

# TypeScript Îß§Ìïë ÏÉùÏÑ±
updates = {}
for choice in choices:
    choice_id = choice.get('choiceId')
    new_text = generate_storytelling(choice)
    updates[choice_id] = new_text

# TypeScript ÏΩîÎìú ÏÉùÏÑ±
typescript_code = """import { DataSource } from 'typeorm';
import { Choice } from '../src/database/entities/choice.entity';

const dataSource = new DataSource({
  type: 'postgres',
  host: 'localhost',
  port: 5432,
  username: 'cto_admin',
  password: 'cto_game_password',
  database: 'cto_game',
  entities: [Choice],
  synchronize: false,
});

const choiceTextUpdates: { [key: number]: string } = {
"""

# ÏÑ†ÌÉùÏßÄ ÏóÖÎç∞Ïù¥Ìä∏ Ï∂îÍ∞Ä
for choice_id, text in sorted(updates.items()):
    typescript_code += f"  {choice_id}: '{text}',\n"

typescript_code = typescript_code.rstrip(',\n') + "\n};\n\n"

# Ïã§Ìñâ ÏΩîÎìú Ï∂îÍ∞Ä
typescript_code += """const updateChoiceTexts = async () => {
  await dataSource.initialize();

  let updatedCount = 0;
  let skippedCount = 0;

  for (const [choiceId, newText] of Object.entries(choiceTextUpdates)) {
    try {
      const result = await dataSource
        .createQueryBuilder()
        .update(Choice)
        .set({ text: newText })
        .where('choiceId = :choiceId', { choiceId: parseInt(choiceId) })
        .execute();

      if (result.affected && result.affected > 0) {
        console.log(`‚úÖ Updated choice ${choiceId}`);
        updatedCount++;
      } else {
        console.log(`‚è≠Ô∏è  Skipped choice ${choiceId} (not found)`);
        skippedCount++;
      }
    } catch (error) {
      console.error(`‚ùå Error updating choice ${choiceId}:`, error);
    }
  }

  console.log('\\nüìä Update Summary:');
  console.log(`‚úÖ Updated: ${updatedCount} choices`);
  console.log(`‚è≠Ô∏è  Skipped: ${skippedCount} choices`);
  console.log(`üìù Total processed: ${Object.keys(choiceTextUpdates).length} choices`);

  await dataSource.destroy();
};

updateChoiceTexts()
  .then(() => process.exit(0))
  .catch((error) => {
    console.error('Error updating choice texts:', error);
    process.exit(1);
  });"""

# ÌååÏùºÎ°ú Ï†ÄÏû•
with open('scripts/update-all-choice-texts.ts', 'w', encoding='utf-8') as f:
    f.write(typescript_code)

print(f"‚úÖ Generated update script for {len(updates)} choices")
print("üìù Saved to scripts/update-all-choice-texts.ts")