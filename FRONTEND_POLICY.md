# AWS 인프라 교육용 턴제 전략 게임 프론트엔드 정책

## 개요 (Introduction)

AWS 인프라 교육용 턴제 전략 게임의 프론트엔드는 React와 TailwindCSS, shadcn/ui로 구성된 웹 애플리케이션으로 개발됩니다. 본 문서는 모바일 환경 대응, 다국어 지원, 백엔드 API 연동, UI/UX 구성 방침, 다이어그램 인터랙션, 상태관리 및 화면 구조, 컴포넌트 설계, 턴 진행 UX 등 프론트엔드 전반의 정책과 구현 기준을 다룹니다. 제시된 기준들은 실제 프로젝트 개발에 바로 적용할 수 있는 수준으로 구체화되어 있으며, 기존 게임 UX 사례와 최신 웹 개발 베스트 프랙티스를 참고했습니다.

## 모바일 대응 UI 구조 (Responsive Layout)

모든 화면은 반응형 웹 디자인 원칙에 따라 모바일 퍼스트로 설계됩니다. TailwindCSS의 유틸리티 클래스와 브레이크포인트를 활용하여 다양한 기기에서 UI 레이아웃이 유연하게 동작하도록 합니다. 예를 들어 Tailwind의 sm, md, lg 등의 프리픽스를 사용해 화면 크기에 따라 적절한 스타일을 적용하며, 미디어 쿼리 없이도 복잡한 반응형 UI를 쉽게 구현할 수 있습니다[1].

각 페이지는 모바일 화면에서는 세로 스택 구조로, 태블릿/데스크톱에서는 가로 레이아웃이나 복합 그리드 레이아웃으로 자동 전환되도록 구성합니다. 또한 뷰포트 메타 태그(`<meta name="viewport" content="width=device-width, initial-scale=1.0">`)를 `<head>`에 포함시켜 모바일 브라우저에서 올바른 뷰포트 스케일을 사용합니다[2]. 주요 UI 컴포넌트(네비게이션 바, 게임 보드, HUD 등)는 CSS Grid와 Flexbox를 활용하여 비율에 맞게 크기가 조정되며, 이미지나 캔버스 요소는 `max-width: 100%` 등으로 화면에 맞춰 리사이징됩니다.

### 터치 인터페이스 최적화

모바일 사용자를 위해 터치 영역을 충분히 크게 확보하고, 중요한 버튼이나 메뉴는 화면 하단 또는 상단에 고정해 한 손 조작이 가능하도록 합니다. 또한 햅틱 피드백이나 터치 홀드 이벤트가 필요한 경우 모바일 전용으로 적용합니다.

### 크로스 브라우징 테스트

iOS Safari, Android Chrome 등 주요 모바일 브라우저에서 레이아웃이 깨지지 않고 가독성과 조작성이 확보되도록 테스트하며, 필요 시 TailwindCSS 커스터마이즈로 추가적인 브레이크포인트를 정의해 디바이스별 최적화를 합니다.

## 다국어 지원 (Internationalization)

본 게임은 다국어(i18n)를 지원하여 전세계 사용자가 이용할 수 있도록 합니다. 구현은 **react-i18next** 라이브러리를 활용하며, 모든 UI 텍스트는 소스 코드에서 분리되어 별도의 번역 파일(JSON 등)로 관리합니다. i18next는 성숙하고 확장성이 뛰어난 국제화 프레임워크로, 대부분의 다국어 처리 이슈를 해결할 수 있는 플러그인을 갖추고 있습니다[3].

각 언어별로 번역 namespace를 구성하고, 컴포넌트에서는 `useTranslation` 훅을 통해 텍스트를 로드합니다. 초기 로딩 시 사용자 브라우저 언어를 자동 감지하여 기본 언어를 설정하고[4], 사용자가 언어를 변경할 수 있는 언어 선택 메뉴(locale switcher)를 제공하여 실시간으로 UI 텍스트가 전환되도록 합니다.

### 번역 리소스 관리

번역 키는 의미있는 그룹으로 네임스페이스화하고 (common, gameplay, errors 등), 실제 문구와 동떨어지지 않게 직관적으로 작성합니다. 모든 문자열에는 형식 지정자(예: 플레이어 이름, 숫자 등)가 올바르게 포함되도록 하고, 복수형 처리나 문장 내 변수 치환은 i18next의 기능을 사용합니다. 특히 턴 수나 자원 수량 같이 변동하는 값은 `t('turn.message', { count: turnCount })` 형식으로 처리해 정확한 단수/복수 표현을 지원합니다.

### RTL 언어 대응

필요시 아랍어 등 RTL(Right-to-Left) 언어의 지원도 고려하여, TailwindCSS의 `dir-rtl` 유틸리티나 i18next의 dir 설정을 활용해 레이아웃 방향을 전환할 수 있게 합니다. Shadcn/ui 컴포넌트들은 기본적으로 접근성에 신경써서 만들어져 있으므로 RTL이나 다국어 문자열에서도 깨짐 없이 동작하지만, 커스텀 스타일 시 `:lang()` CSS 셀렉터 등을 사용해 언어 특성에 맞게 세밀한 조정도 가능합니다.

### 다국어 테스트

주요 언어(한국어, 영어 등)를 포함해 지원 언어별로 UI 길이 변화에 따른 레이아웃 검토를 진행합니다. 예를 들어 영어 대비 독일어나 한국어는 문자열 길이가 길어질 수 있으므로 버튼 너비, 메뉴 배치가 깨지지 않도록 하고, 폰트도 다국어 문자를 지원하는 웹폰트를 사용합니다.

## 백엔드 정책 기반 API 연동 (API Integration)

프론트엔드는 이전 백엔드 정책에서 정의된 RESTful API 또는 GraphQL 스키마를 준수하여 통신합니다. 게임의 진행과 상태 관리를 위해 HTTP API 연동 모델을 수립하며, 클라이언트-서버 간 데이터 교환 규칙을 명확히 따릅니다. 예를 들어, 로그인/인증, 게임 방 생성, 턴 시작/종료, 액션 실행, 상태 조회 등의 기능에 대응하는 API 엔드포인트를 식별하고, 이를 호출하는 전용 함수나 훅을 구현합니다.

### API 호출 구조

fetch API 또는 Axios 등을 래핑한 서비스 모듈을 만들어, 모든 API 호출을 한 곳에서 관리합니다. 이 모듈은 백엔드 정책에 명시된 공통 헤더(예: 인증 토큰, 요청 ID 등)와 에러 처리 방식을 내장합니다. 백엔드 응답의 데이터 포맷(JSON 스키마)에 따라 프론트엔드 모델을 정의하며, 필요한 경우 데이터 변환(예: snake_case → camelCase)도 이 레이어에서 수행합니다.

### 상태 관리 연계

서버에서 받은 게임 상태 데이터(예: 현재 턴, 플레이어 자원, AWS 리소스 배치 현황 등)는 전역 상태로 저장되어 UI에 반영됩니다. 이때 Redux Toolkit의 `createAsyncThunk` 또는 React Query/RTK Query를 활용하여 비동기 API 호출과 상태 업데이트를 관리합니다. 이러한 미들웨어를 사용함으로써 비동기 작업을 리듀서 로직에서 분리하여 사이드 이펙트를 관리할 수 있습니다[5].

예를 들어, "턴 종료" 액션을 디스패치하면 내부적으로 API 호출(thunk)이 이루어지고, 응답 결과에 따라 "게임 상태 업데이트" 액션으로 리듀서가 상태를 갱신하는 식입니다.

### 에러 및 예외 처리

백엔드 정책에서 정의한 에러 코드를 기반으로, 프론트엔드는 사용자에게 친숙한 피드백을 제공합니다. 네트워크 오류나 인증 만료 등의 상황에서는 공통 에러 핸들러를 통해 토스트 알림이나 모달 다이얼로그를 표시하고, 심각한 오류의 경우 게임 진행을 일시 정지시킵니다.

예를 들어 API 응답이 401 Unauthorized이면 자동으로 로그인 화면으로 전환하거나 세션 재발급 절차를 밟고, 500번대 서버 오류는 사용자에게 사과 메시지와 함께 재시도 옵션을 줍니다.

### 실시간 업데이트

턴제 게임이지만 멀티플레이어나 백엔드 시뮬레이션에 따라 실시간 이벤트가 필요하다면 WebSocket이나 SSE(Server-Sent Events) 등도 고려합니다. 이 경우 프론트엔드에서 Socket 연결을 관리하고, 받은 이벤트를 Redux 액션으로 디스패치하여 상태를 변경하는 패턴을 따릅니다. (예: 상대 턴 종료 이벤트를 수신하면 우리 측에서 턴 시작 액션 디스패치)

## 게임 HUD 및 UI 구성 참고 (HUD & Resource Management UI)

턴제 전략 게임의 HUD(Heads-Up Display)와 자원 관리 인터페이스는 다른 전략 게임들의 모범 사례를 참고하여 설계합니다. 화면에는 마이크로 정보(현재 선택한 자원 또는 유닛의 상세 상태)와 매크로 정보(전체 턴 진행 상황, 남은 자원, 전체 네트워크 상태 등)가 균형있게 표시되어야 합니다[6].

예를 들어 화면 상단에는 전체 게임 상태바를 배치하여 현재 턴 번호, 총 턴 제한, 플레이어 점수 또는 진행도, 주요 글로벌 자원(예산, 트래픽 등)을 표시합니다. 동시에 화면 하단이나 사이드에는 선택된 개별 AWS 구성 요소의 상세 정보(예: EC2 인스턴스의 상태, 비용, 성능 수치 등)를 나타내는 정보 패널을 제공합니다. 이렇게 함으로써 플레이어는 개별 액션의 영향과 전체 인프라 상황을 한눈에 파악할 수 있습니다[7].

### HUD 구성 요소

#### 자원 표시 바(Resource Bar)
게임에서 관리하는 주요 자원(예: 예산 크레딧, 사용 가능한 EC2/Lambda 실행 시간, 트래픽 용량 등)을 아이콘과 함께 숫자로 표시합니다. 실시간 업데이트를 통해 턴 진행 중 자원 증감이 즉각 반영되며, 자원 한계치 도달 시 색상 강조(예: 빨간색 경고)로 알립니다.

#### 상태 아이콘 및 알림
AWS 인프라 상태를 나타내는 아이콘 (예: 서버 정상/장애, 네트워크 지연 경고 등)을 HUD 일부에 배치합니다. 중요한 이벤트(장애 발생, 보안 위협 등)가 일어나면 화면 모서리나 별도 로그 영역에 알림 아이콘이 깜박이거나 강조되어, 플레이어가 알아차릴 수 있게 합니다[8]. 이러한 시각적 노티피케이션은 절대 플레이어 모르게 지나치지 않도록 충분히 눈에 띄게 디자인합니다.

#### 액션 버튼 및 단축키 표시
화면 한쪽에는 사용자가 현재 턴에 실행할 수 있는 액션들(예: "새 자원 배포", "구성 변경", "턴 종료")을 버튼으로 제공하고, 각 버튼에 툴팁으로 단축키를 표시하여 숙련된 사용자는 키보드로도 조작할 수 있게 합니다. (예: "턴 종료 (단축키: E)") 이러한 단축키는 게임의 마스터리를 높이는 데 도움을 주지만, 모든 명령은 시각적 UI로도 수행 가능하도록 하여 초보자도 이탈되지 않도록 합니다[9].

#### 이벤트 로그/콘솔
HUD 하단이나 측면에 텍스트 형태의 이벤트 로그 패널을 두어, 턴별로 일어난 주요 사건을 순서대로 표시합니다. 예를 들어 "턴 5: S3 버킷에 접근 폭주 발생, 자동 스케일 업 수행 (+2 EC2)"와 같은 로그를 남겨 플레이어가 지난 상황을 복기할 수 있게 합니다. 이 로그는 스크롤이 가능하며, 중요한 이벤트는 강조 표시나 아이콘으로 구분합니다.

#### 컨텍스트 메뉴/툴팁
지도 또는 다이어그램 상의 특정 요소(AWS 서비스 아이콘 등)를 클릭하면 해당 요소와 상호작용할 수 있는 컨텍스트 메뉴(예: "상세보기", "업그레이드", "삭제")가 나타나도록 합니다. 또한 각 UI 아이콘이나 수치에는 마우스를 올리면 의미를 설명하는 툴팁을 제공하여, 처음 접하는 사용자도 UI 요소의 용도를 쉽게 이해할 수 있게 합니다.

### UI 디자인 원칙

UI 전반은 일관된 디자인을 유지하여 사용자가 예측 가능하도록 합니다. 색상과 아이콘은 AWS 공식 디자인 가이드나 친숙한 클라우드 심볼을 활용하고, 폰트와 UI 요소 스타일은 TailwindCSS를 통해 통일성을 갖춥니다. 불필요한 정보나 장식은 배제하고, 현재 컨텍스트에 필요한 정보만 보여주어 인지 부하를 낮춥니다[10][11]. 이는 교육용 게임으로서 사용자가 학습 내용에 집중하면서도 게임 진행 상황을 명확히 파악하도록 돕습니다.

## 인터랙티브 다이어그램 설계 및 정책 (Interactive Diagram UX)

이 게임의 핵심 UI 중 하나는 AWS 인프라를 시각적으로 구성할 수 있는 인터랙티브 다이어그램입니다. React용 다이어그램 라이브러리인 **React Flow**를 도입하여, 사용자가 AWS 리소스들을 노드(node)와 엣지(edge)의 형태로 배치하고 연결할 수 있는 캔버스를 구현합니다[12]. 이를 통해 복잡한 클라우드 아키텍처를 시각적 플로우차트처럼 표현하여 학습효과를 높입니다.

### 구성도 인터랙션 정책

#### 노드 추가 및 배치
사용자들은 좌측 컴포넌트 패널에서 AWS 서비스 아이콘(노드)을 드래그 앤 드롭하여 캔버스에 추가할 수 있습니다[13]. 노드를 드래그하는 동안 가이드라인이 표시되어 격자에 맞게 정렬을 돕고, 놓았을 때 자동으로 해당 서비스의 기본 설정(예: 기본 용량, 비용)이 상태에 반영됩니다.

#### 노드 간 연결
노드 간 연결은 노드에 있는 연결 포트를 드래그하여 다른 노드로 끌어와 선을 이어 만드는 방식으로 이루어집니다. 이러한 엣지 연결은 실시간으로 유효성 검사를 거쳐, 허용되지 않는 연결(예: 인터넷 게이트웨이를 RDS에 직접 연결 등)은 생성되지 않도록 합니다. 연결이 완성되면 선 색상이나 아이콘으로 연결 유형(예: 네트워크, 데이터 흐름)을 표시합니다.

#### 속성 편집
노드를 클릭하면 해당 자원의 상세 정보를 편집할 수 있는 속성 패널이 우측에 나타납니다. 여기서 인스턴스 크기 변경, 연결 설정 수정 등 세부 조정을 할 수 있으며, 이러한 변경은 즉시 다이어그램과 상태 데이터에 반영됩니다.

#### 줌 및 이동
다이어그램 상에서의 줌(Zoom) 및 이동(Pan) 기능을 제공하여 큰 아키텍처도 편리하게 탐색할 수 있도록 합니다. 멀티터치 환경에서는 핀치 줌과 두 손가락 팬을 지원하고, 데스크톱에서는 마우스 휠 줌과 드래그 이동을 지원합니다. React Flow 기본 기능으로 제공되는 줌/이동 이벤트를 활용하되, 너무 과도한 줌 단계에서는 중요한 노드들이 누락되지 않게 최소/최대 배율을 제한합니다.

#### Undo/Redo 및 저장
사용자의 다이어그램 편집 작업(노드 추가/삭제, 연결 변경 등)은 순차적으로 기록되어 실수로 잘못 놓은 경우 Undo를 통해 이전 상태로 되돌릴 수 있습니다. 여러 단계를 차례로 되돌릴 수 있으며, 되돌린 후 다시 Redo도 가능합니다. 또한 현재 다이어그램 상태를 서버에 저장하거나 불러오는 기능을 넣어, 한 턴에서 구성한 아키텍처를 다음 턴이나 다음 세션에도 이어서 사용할 수 있게 합니다.

#### Draw.io 연동
개발 초기 설계 단계에서는 draw.io로 작성된 아키텍처 다이어그램을 가져와 React Flow 노드 배열로 변환하거나, 반대로 게임 내에서 구축한 다이어그램을 이미지로 익스포트하는 기능도 고려합니다. 이를 통해 학습자는 자신이 만든 클라우드 아키텍처를 문서화하거나 공유할 수 있습니다.

### 기능적 고려사항

React Flow 라이브러리를 통해 제공되는 드래그, 연결, 이벤트 훅을 활용하여 사용자 액션에 따른 게임 내 로그 및 상태 변화를 처리합니다. 예를 들어 사용자가 EC2 인스턴스를 배치하면, 내부적으로 해당 액션을 나타내는 Redux 액션 (ADD_INSTANCE)이 디스패치되고, 이에 따라 백엔드 API 호출로 자원 소모 및 배치 결과를 검증한 후 상태를 업데이트합니다.

또한 접근성을 위해 다이어그램 요소들도 키보드 내비게이션이 가능하도록 tabindex와 ARIA 레이블을 설정합니다. 시각 장애 사용자를 위해 간략한 텍스트 모드 설명도 제공할 수 있는데, 예컨대 현재 다이어그램을 "VPC 내에 퍼블릭 서브넷 2개와 EC2 3대, RDS 1대 연결된 구성" 식의 요약으로 출력하는 기능을 고려합니다.

## 상태 관리 구조 (State Management)

게임의 프론트엔드 상태 관리는 전역 상태와 지역 상태를 적절히 구분하여 구성합니다. **Redux Toolkit**을 중심으로 상태를 관리하되, React의 Context API를 보조적으로 활용합니다. Redux를 도입하는 이유는 여러 컴포넌트에서 필요한 공용 게임 상태를 효율적으로 관리하고, 컴포넌트 생명주기를 넘어 persist되어야 하는 데이터를 다룰 수 있기 때문입니다[14]. 특히 턴 진행, 플레이어 정보, 게임 보드 상태 등은 다수 컴포넌트에 걸쳐 참조되므로 전역으로 관리합니다.

### 스토어 구조

Redux의 feature 기반 구조로 폴더를 구성하며[15], 예를 들어 user, game, diagram, ui 등의 슬라이스(slice)를 정의합니다:

- **user**: 로그인한 사용자 정보, 설정(언어, 볼륨 등)을 저장
- **game**: 게임 진행 관련 상태 (현재 턴 번호, 현재 플레이어, 승리조건 진행도 등)와 주요 게임 매커닉 데이터를 보유
- **diagram**: 현재 AWS 인프라 다이어그램의 노드/엣지 정보와 관련 메타데이터 (예: 선택된 노드 ID, 편집 모드 플래그 등)를 저장
- **ui**: UI 상태(로딩 스피너, 모달 열림 상태, 알림 메시지 등 일시적 UI 상태)를 관리

각 슬라이스는 해당 도메인에 한정된 액션 및 리듀서를 가지며, 불변성을 유지하면서 상태를 업데이트합니다. 예를 들어 `game/endTurn` 액션 발생 시 game 슬라이스 리듀서에서 턴 번호 증가, 현재 플레이어 변경 등의 상태 변화를 처리합니다.

### 미들웨어 및 비동기 처리

Redux Toolkit의 `createAsyncThunk`를 활용하거나, 필요한 경우 redux-saga를 도입해 복잡한 턴 진행 흐름을 효과적으로 제어합니다. 예를 들어 턴을 종료하는 과정에서 "엔드포인트 호출 → 응답 대기 → 응답에 따라 여러 상태 업데이트 → 다음 턴 시작"의 일련의 과정이 필요하다면, saga로 이 시퀀스를 표현해 관리할 수 있습니다. saga 또는 thunk 내부에서는 API 호출 (위에서 정의한 서비스 모듈 사용)을 수행하고, 성공/실패에 따라 적절한 액션을 디스패치합니다.

또한 **reselect** 라이브러리를 사용하여 메모이제이션된 selector를 구현함으로써 파생 상태 계산을 효율화합니다. 예를 들어 전체 다이어그램 상태에서 특정 VPC에 속한 자원들의 리스트를 계산하거나, 현재 플레이어가 가진 자원 합계를 계산하는 selector를 두어 컴포넌트에 제공하면, 상태 구조를 정규화하고 퍼포먼스를 높일 수 있습니다.

### 로컬 상태

모달 열림 여부, 일시적 입력값 등 순간적인 UI 상태는 React 컴포넌트의 로컬 state나 Context로 관리합니다. 단, 이러한 상태도 URL 라우팅과 연계되거나 여러 컴포넌트에서 동시에 필요하다면 전역 state로 격상시킵니다.

상태 변경에 따라 UI를 효율적으로 업데이트하기 위해 React의 불변 데이터 패턴을 지키고, 가능하면 컴포넌트를 memo로 감싸 불필요한 재렌더를 방지합니다. DevTools (Redux DevTools)를 활성화하여 디버깅 및 time-travel이 가능하게 하고, 주요 액션(턴 시작/종료 등)은 DevTools State 탭에서 쉽게 추적할 수 있도록 액션 로그 메시지를 의미있게 작성합니다.

## 주요 화면 구성 (Main Screens Layout)

프론트엔드 애플리케이션은 몇 가지 주요 화면(페이지)으로 구성되며, React Router 등을 이용해 전환됩니다. 각 화면의 구성과 역할은 다음과 같습니다:

### 1. 로그인 및 메인 메뉴 화면

사용자가 게임에 입장하기 전에 볼 수 있는 화면으로, AWS 교육용 게임의 특성상 AWS 자격 증명 연동 또는 간단한 닉네임 입력을 통해 시작할 수 있습니다. 이 화면은 반응형 일러스트 또는 게임 로고와 함께, "싱글플레이 시작", "멀티플레이 대기실", "설정" 등의 버튼을 배치합니다. TailwindCSS로 미려한 버튼 스타일과 애니메이션(hover, active)을 적용하고, shadcn/ui의 Card 컴포넌트 등을 활용해 메뉴 옵션들을 카드 형태로 배치할 수도 있습니다.

### 2. 게임 로비/설정 화면

싱글플레이 시나리오 선택 또는 멀티플레이 매치메이킹을 위한 화면입니다. 예를 들어 교육 시나리오별로 "VPC 구성 연습", "웹서비스 장애 대응" 등의 리스트를 보여주고 난이도 등을 표시합니다. 또는 멀티플레이의 경우 방을 만들거나 참가하는 UI(HUD 스타일의 팝업 혹은 별도 페이지)로 구성합니다. 이 화면에서 사용자는 게임 시작 전에 환경 설정(사용 언어, 사운드, 튜토리얼 on/off 등)을 할 수 있으며, shadcn/ui의 Dialog나 Sheet 컴포넌트를 이용해 오버레이 형태로 옵션 창을 띄울 수 있습니다.

### 3. 게임 플레이 화면

본 게임의 핵심 화면으로, HUD, 메인 다이어그램/지도 영역, 정보 패널로 크게 구성됩니다. 화면의 좌측 또는 상단에는 앞서 설명한 HUD 요소들(자원 바, 턴 표시 등)이 자리잡고, 중앙에는 AWS 인프라 다이어그램 또는 맵이 보여집니다. 우측이나 하단에는 선택된 구성 요소의 상세 정보와 로그가 나타나는 패널이 위치합니다.

이 화면은 가장 복잡하며, 반응형 레이아웃으로 모바일에서는 다이어그램을 세로로 길게 표시하고 HUD 일부를 아이콘으로 축소하는 등 재배치합니다. 턴 진행 버튼(예: "턴 종료")도 이 화면에 뚜렷하게 표시되며, 조건에 따라 활성/비활성 상태를 동적으로 나타냅니다.

### 4. 결과/리포트 화면

게임 종료 후 나타나는 화면으로, 성취한 결과(점수, 획득 배지 등)와 개선할 점, 학습 포인트를 요약해 보여줍니다. AWS 모범 아키텍처와 플레이어의 아키텍처를 비교하거나, 잘한 점과 놓친 점을 피드백합니다. UI 구성은 요약 카드와 그래프 등을 포함하며, "다시 플레이", "메인으로" 버튼이 있습니다. 이 화면은 교육적 피드백을 주는 역할이므로, 텍스트와 도식(차트 등)을 조화롭게 배치하고 시각적 강조를 통해 핵심 메시지를 전달합니다.

### 네비게이션 및 전환

React Router로 각 화면을 라우팅하며, 페이지 전환 시 페이드 인/아웃 또는 슬라이드 애니메이션을 적용해 부드러운 전환 효과를 줍니다. 예컨대 메인 메뉴 → 게임 화면 전환 시 로딩 스피너와 함께 화면이 천천히 밝아지며 게임 UI가 등장하도록 연출합니다. 또한 멀티플레이 대기실 등에서는 실시간 업데이트가 필요하므로 해당 라우트에 진입 시 WebSocket 연결을 맺고, 떠날 때 연결을 정리하는 등 라이프사이클을 관리합니다.

## 사용자 인터랙션 정책 (User Interaction Policies)

사용자 인터랙션에 대한 정책은 **직관성**, **즉각적 피드백**, **일관성** 세 가지를 중점으로 합니다.

### 포인팅 장치 조작

마우스 사용자에 대해서는 클릭, 더블클릭, 드래그 등의 동작을 캔버스와 UI에 자연스럽게 매핑합니다. 예를 들어 다이어그램에서 노드를 클릭하면 상세 패널이 나타나고, 더블클릭하면 편집 모드로 전환, 드래그하면 위치 이동이 일어납니다. 이러한 조작법은 유저 가이드에 명시하고, 처음 튜토리얼에서는 하이라이트나 애니메이션으로 알려줍니다. 터치 환경에서는 탭과 롱프레스(long press)를 대응시켜, 탭 시 선택/확인, 롱프레스 시 컨텍스트 메뉴 표시 등으로 매핑합니다.

### 키보드 조작

전략 게임으로서 키보드 단축키를 제공하여 숙련자들이 효율적으로 플레이할 수 있게 합니다. 예를 들어 방향키로 다이어그램 뷰를 스크롤하거나 Delete 키로 선택 노드 삭제, Enter 키로 턴 종료 등을 할당합니다. 이때 UI 상에 단축키를 함께 표시하여 학습을 도우며, 핵심 명령에는 모두 핫키를 마련합니다[16][17]. 키보드 포커스가 버튼이나 링크에 있을 때 Enter/Space로 클릭 대체 동작이 가능하도록 하고, ESC 키로 메뉴 닫기 등의 UX도 구현합니다.

### 즉각적인 피드백

사용자의 모든 조작에는 명확한 피드백이 수반됩니다. 버튼을 클릭하면 눌리는 애니메이션과 함께 사운드 효과(선택사항)가 재생되고, 액션이 성공적으로 접수되면 HUD나 관련 UI에 변화가 나타납니다. 예를 들어 "EC2 인스턴스 추가" 액션을 수행하면 해당 노드가 다이어그램에 생성되고, 자원 바의 EC2 사용량 숫자가 즉시 증가하는 등 원인-결과가 바로 보이도록 합니다. 또한 UI 상호작용에 시각/청각 피드백을 부여하여 클릭, 드래그 등의 행동이 인지될 때마다 사용자에게 반응을 제공합니다[18].

### 오류 방지 및 처리

사용자가 실수로 잘못된 액션을 하지 않도록 인터랙션 가드를 둡니다. 예를 들어 아직 턴이 아닌 플레이어가 액션을 시도하면 해당 버튼을 비활성화하고 툴팁으로 "상대 턴 진행중" 메시지를 보여줍니다. 또한 중요한 결정(예: 대규모 리소스 투입, 턴 종료)에는 한 번 더 확인(confirm) 모달을 띄워서 실수를 줄입니다. 만약 잘못된 조작이나 금지된 행동을 했을 경우, 이를 설명하는 경고 메시지를 HUD에 띄우고 해당 행동을 무시합니다.

### 일관성 있는 인터랙션

앱 전반에 걸쳐 유사한 조작은 유사한 결과를 가져오도록 디자인합니다. 예를 들어 더블클릭 동작은 언제나 상세보기로 통일하고, 드래그 앤 드롭은 순서변경이나 추가 동작으로만 사용합니다. 이렇게 패턴화된 인터랙션은 사용자가 여러 화면을 이동해도 학습한 조작법을 그대로 적용할 수 있게 해 주어 사용자 혼란을 줄입니다[19].

### 접근성 고려

시각, 청각 장애가 있는 사용자도 게임을 즐길 수 있도록 키보드-only 조작, 스크린리더 호환, 색약 모드 등을 지원합니다. 모든 인터랙티브한 요소에 ARIA 레이블을 달아 스크린 리더가 의미를 읽어줄 수 있게 하고, 색상만으로 정보를 전달하지 않도록 아이콘 모양이나 텍스트 병기를 활용합니다. 또한 UI 대비(contrast)를 충분히 높여 어두운 화면에서도 가독성을 유지하고, 필요시 고대비 테마를 옵션으로 제공합니다.

## UI 구성요소 설계 (React + TailwindCSS + shadcn/ui)

UI 구현은 React 컴포넌트를 기반으로 하며, 스타일링에는 TailwindCSS, 그리고 고급 컴포넌트에는 shadcn/ui의 프리셋을 활용합니다. shadcn/ui는 Radix UI 프리미티브를 활용하여 TailwindCSS로 스타일된 반응형 React 컴포넌트 모음으로서, 접근성과 디자인 일관성을 동시에 추구합니다[20]. 이를 통해 Modal, Dropdown, Tooltip 등 공통 UI 요소를 빠르게 구축하고, 필요에 따라 소스 코드를 직접 수정하여 커스터마이징할 수 있습니다.

### TailwindCSS 유틸리티 클래스 전략

디자인 시스템 전반에 걸쳐 TailwindCSS의 원칙을 활용합니다. 레이아웃, 간격(spacing), 타이포그래피, 색상 등은 미리 설정한 테마 값(예: primary 색상은 AWS 블루 계열 등)을 사용하고, 컴포넌트별로 필요한 유틸리티 클래스를 조합하여 구현합니다. 반복되는 스타일 패턴(예: 카드 스타일 박스, 섹션 컨테이너 등)은 TailwindCSS `@apply`를 사용한 커스텀 클래스나 별도 컴포넌트로 추출하여 재사용성을 높입니다.

shadcn/ui 컴포넌트도 TailwindCSS로 스타일이 적용되어 있으므로, 전역 테마 변경(라이트/다크 모드 전환 등) 시 CSS 변수만 조정하여 전체 UI 톤을 바꿀 수 있습니다. 다크 모드 지원을 위해 `data-theme="dark"` 속성을 `<html>`에 주고 shadcn/ui의 다크 모드 스타일을 활성화하는 방식으로 구현하며, TailwindCSS의 `dark:` 프리픽스를 병행해 수작업한 스타일에도 일관되게 적용합니다.

### 컴포넌트 계층 구조

Atomic Design 원칙을 참고하여 원자(Atoms) 단위의 버튼, 아이콘, 입력 필드 등을 만들고 이를 조합하여 분자(Molecules) 수준의 패널, 리스트, 카드 등을 구성합니다. 예를 들어 "자원 표시 바" 컴포넌트는 아이콘(원자) + 텍스트(원자) + 툴팁(분자, shadcn Tooltip 조합)으로 이루어진 분자 컴포넌트이며, 이것들을 모아 HUD(유기체, Organism) 컴포넌트를 형성합니다. 이렇게 계층적으로 설계하면 변경에 유연하고 테스트가 용이해집니다.

스토리북 등의 도구를 사용해 주요 컴포넌트를 카탈로그화하고, 디자인 시스템 준수 여부를 수시로 검증합니다. 컴포넌트 프로퍼티는 가능한 한 불변으로 받아서 랜더링만 수행하고, 상태는 상위에서 내려받는 방식으로 통일하여 예측 가능한 UI 동작을 확보합니다. 또한 컴포넌트 간 프롭 드릴링을 줄이기 위해 Context를 적절히 사용하되, 너무 광범위한 컨텍스트는 지양하고 필요 최소한 범위로 한정합니다.

### 예시 UI 구성요소 설계

#### 버튼(Button)
TailwindCSS 기본 버튼 스타일(`px-4 py-2 rounded font-medium`)에 기본(primary), 보조(secondary), 위험(danger) 등의 variant를 Tailwind 구성으로 정의하고, shadcn/ui의 `<Button>` 코드를 가져와 확장합니다. 버튼에는 아이콘을 넣을 수 있는 슬롯을 만들어 좌측에 AWS 서비스 아이콘 등을 배치 가능하게 합니다. Disabled 상태일 때 투명도와 커서 스타일을 조정해 비활성화 표현을 하고, hover/active 상태 시 미묘한 음영이나 변형을 주어 클릭 가능 피드백을 줍니다.

#### 모달(Dialog)
shadcn/ui의 Dialog 컴포넌트를 사용하여 커스텀 모달을 구현합니다. 예를 들어 "게임 일시정지/설정" 모달이나 "확인 대화상자" 등에 활용하며, TailwindCSS로 크기나 위치를 조정합니다. 모달은 열릴 때 배경에 반투명 어둡게 dim 효과를 주고, ESC 키나 배경 클릭으로 닫히도록 하여 UX 편의성을 높입니다. 접근성을 위해 모달 열리면 focus-trap이 적용되어 모달 내 컨트롤만 탭 순서에 들어가고, 스크린리더에게는 적절한 `aria-modal` 속성을 부여합니다.

#### 토스트 알림(Toast)
사용자 행동 피드백이나 시스템 메시지를 위해 shadcn/ui의 Toast (또는 Sonner) 컴포넌트를 활용합니다. 우측 상단 등에 작게 나타났다 사라지며, 성공은 초록, 오류는 빨강 등으로 색상 차별화합니다. TailwindCSS로 애니메이션 (`transition ease-in duration-300` 등)을 설정하여 부드럽게 슬라이드 인/아웃합니다.

#### 아이콘 및 일러스트
AWS 서비스의 로고 아이콘들을 SVG로 가져와 React 컴포넌트화하고, TailwindCSS `text-[color]` 유틸로 색상을 테마에 맞게 조정합니다. 작은 아이콘들은 히어로콘(Heroicons) 등으로 보충하고, 중요한 일러스트는 반응형으로 크기 조절하며 lazy loading합니다.

## 턴 진행 UX 및 사용자 피드백 (Turn-Based Progression UX & Feedback)

턴제 게임의 특성을 살려 턴 진행 상황을 시각적으로 잘 전달하고 사용자에게 충분한 피드백을 제공하는 것이 중요합니다.

### 턴 표시 및 전환

화면 상단 HUD에 현재 턴 번호와 현재 플레이어를 명시적으로 표시합니다. 멀티플레이의 경우 "플레이어 A의 턴"과 같이 현재 턴 주체를 강조하고, 상대 턴 동안에는 해당 표시를 깜빡이거나 회색 처리하여 "대기 중" 상태임을 나타냅니다. 턴 변경 시에는 화면 중앙에 잠시 턴 전환 애니메이션이나 배너(예: "플레이어 B의 턴 시작")를 띄워 플레이어가 인지하도록 합니다. 이때 짧은 사운드 효과(차임 등)를 곁들여 청각적으로도 피드백을 줍니다.

### 진행 흐름 안내

게임이 진행됨에 따라 턴 타이머(제한시간이 있는 경우)를 HUD에 표시하고 경과를 시각적으로 보여줍니다 (원형 타이머 게이지 등). 턴이 거의 끝나갈 때는 타이머 색상을 변경하거나 경고음을 통해 남은 시간이 적음을 경고합니다. 만약 제한시간 없이 사용자가 턴 종료를 누르는 방식이라도, 모든 가능한 액션을 수행했음을 유도하기 위해 주요 미완료 작업이 있을 경우 턴 종료 버튼 근처에 알림을 표시합니다 (예: "남은 사용 가능 예산 있음" 등의 힌트).

### 액션 결과 피드백

한 턴 내에서 사용자가 수행하는 주요 액션들에 대해서는 즉각적인 피드백과 함께, 턴이 끝날 때 추가적인 요약 피드백을 줍니다. 예를 들어 사용자가 새로운 EC2 인스턴스를 배치하면:

- **즉시**: 다이어그램에 EC2 노드 생성 + HUD 자원 업데이트 + "EC2 인스턴스 배치됨" 토스트 알림 출력
- **턴 종료 시**: 해당 턴에 플레이어가 수행한 핵심 작업 목록을 요약하여 화면에 잠시 표시

이를 통해 플레이어가 자신이 한 행동을 다시 상기하고 넘어갈 수 있게 합니다.

### 시각적 효과 활용

턴이 바뀌는 순간이나 주요 이벤트 발생 시 화면 일부에 하이라이트나 애니메이션 효과를 사용합니다. 예를 들어 중요 인프라에 장애가 발생한 이벤트가 일어나면 해당 노드 아이콘을 흔들리게 하거나 붉은 테두리를 깜빡이게 하는 등 주의를 끄는 효과를 줍니다. 또한 성공적으로 미션을 수행했을 경우 화면에 축하 효과(폭죽 애니메이션 등 소소한 연출)를 추가해 성취감을 높입니다. 이러한 시각 효과들은 남용하지 않되, 교육 게임의 동기부여를 위해 적절히 활용합니다.

### 사용자 행동 로그 및 리플레이

앞서 HUD 이벤트 로그에 기록된 턴별 사건들은 리플레이 기능으로 이어질 수 있습니다. 플레이어가 원하면 이전 턴들의 로그를 검토하거나, 특정 턴을 다시 돌려보는(시각적으로 재현하는) 기능을 넣어 학습을 복습하도록 유도합니다. 이를 통해 사용자는 "내가 3턴 전에 어떤 조치를 해서 지금 이런 결과가 나왔구나"를 깨달을 수 있습니다.

또한 멀티플레이 시에는 채팅 및 로그를 통합하여, 같은 팀 혹은 상대와 간단한 의사소통을 하거나 턴 진행 내역을 공유합니다. 이때 채팅에도 턴 표시를 붙여 언제 발신된 메시지인지 분명히 합니다.

### 피드백의 명확성

전체적으로, 플레이어의 행동에 대한 시스템의 반응은 명확하고 즉각적이어야 합니다. 게임 내 모든 중요한 사건은 플레이어에게 인지되어야 하며, 화면 밖에서 조용히 지나가는 일이 없도록 해야 합니다[8]. 이를 위해 사운드, 애니메이션, 화면 표시 등을 종합적으로 활용하되, 지나친 방해가 되지 않는 선에서 균형을 맞춥니다.

예를 들어 턴 종료 버튼을 누르면 다음 턴 UI로 업데이트되기까지 짧은 로딩 스피너와 "턴 계산 중..." 메시지를 보여주고, 완료되면 바로 새로운 턴 데이터를 HUD에 반영합니다. 만약 계산 중 특별한 이벤트가 발생했다면 (예: AWS 비용 초과로 페널티) 턴 시작 시 그 내용을 다이얼로그나 강조된 텍스트로 피드백합니다.

## 참고 문헌

[1] [2] Responsive design - Core concepts - Tailwind CSS
[3] [4] A Guide to React Localization with i18next | Phrase
[5] [15] Best Practices for Structuring Redux Applications / Blogs / Perficient
[6] [7] [8] [9] [16] [17] UI Strategy Game Design Dos and Don'ts
[10] [11] [18] [19] UX and UI in game design: exploring HUD, inventory, and menus
[12] [13] Synergy Codes — React Flow: Everything you need to know
[14] Why You Should Use Redux in 2024 by Mark Erikson
[20] Shadcn UI React Components - Shadcn.io

---

以上の方침に 따라 프론트엔드 구현을 진행함으로써, 사용자에게 반응 빠르고 이해하기 쉬운 인터페이스를 제공하고, AWS 인프라 학습이라는 목적을 달성하는 동시에 게임으로서의 재미와 도전의 요소를 놓치지 않을 것입니다. 각각의 정책과 가이드라인은 개발 단계에서 지속적으로 참고하여, 최종 결과물이 교육 효과와 사용자 경험 면에서 모두 우수하도록 합니다.